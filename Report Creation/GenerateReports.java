import java.util.*;
import java.io.*;
import java.nio.file.*;

/**
 * GenerateReports, will read through files created from saving stylechcker and create a user
 * readable version.  Does not print the lines of the error - will refactor code to do that.
 * @author Samuel Schoeneberger
 */
public class GenerateReports {

    /** number of text files to be read, generated by CompileAndExecuteScript.sh */
    public static final int READ_TEXT_FILES = 6;
    
    /** String printed out that is always at the end of usable data from file. */
    public static final CharSequence AUDIT_COMPLETE = "Audit done.";
    
    /** Tells us indent level, to skip over more importantly. */
    public static final CharSequence INDENT_LEVEL = "indent level";
    
    /** Same as above; sequence to skip. */
    public static final CharSequence INDENT_LEVEL_TWO = "(If this isn't";
    
    /** Checking for another line to skip. */
    public static final CharSequence DOING_STYLE = "** Doing style";
    
    /** Last to skip - from this point forwar, we care about input. */
    public static final CharSequence STARTING_AUDIT = "Starting audit...";
    
    public static final int AFS_START_SUBSTRING_LENGTH = 28;
    
    /**
     * Main method.  Program execution and all that.
     * Checks if we have the right number of arguments (1), then checks through the
     * first argument for a folder of folder of output files to generate reports.
     * @param args command line arguments
     */
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage: java GenerateReports directory_name");
            System.exit(1);
        }
        
        File folder = new File(args[0]);
        if ( !folder.isDirectory() ) {
            System.out.println("Error: supplied directory not a directory.");
            System.exit(1);
        }
        
        //Folders inside the directory
        File[] folders = folder.listFiles();
        
        //Files in each directory
        //[Number of folders][Number of text files to be read.]
        File[][] files = new File[folders.length][READ_TEXT_FILES];
        
        //Get files from each directory - the output.*.txt files specifically
        for ( int i = 0; i < folders.length; i++ ) {
            files[i] = folders[i].listFiles(new FilenameFilter(){
                @Override
	            public boolean accept(File directory, String fileName) {
                    return fileName.endsWith(".txt");
	            }
	        } );
        }
        
        PrintWriter writer = null;
        Scanner reader = null;
        
        for ( int i = 0; i < folders.length; i++ ) {
            
            // Setting up style file to be read.
            String styleFile = folders[i] + "/output_style.txt";
            File style = new File(styleFile);
            
            // Setting up report file to be written to.
            String reportFile = folders[i] + "/Report.txt";
            File report = new File(reportFile);
            
            // Making sure that report doesn't already exist.
            if ( report.exists() ) {
                report.delete();
            }
            
            // Making sure we have a style file to check
            if ( !style.exists() ) {
                System.out.println("No output for style in folder: " + folders[i]);
                continue; //Skip iteration, we couldn't find that style file.
            }
            
            // Making sure we can create that report file.
            try {
                report.createNewFile();
            } catch ( Exception e ) {
                System.out.println(e.getMessage());
                System.exit(1);
            }
            
            // Setting up our reader/writer combo.
            try {
                writer = new PrintWriter(report, "UTF-8");
                reader = new Scanner(style);
            } catch ( Exception e ) {
                System.out.println(e.getMessage());
                System.exit(1);
            }
            
            String javaFileName = "";
            int numTabLines = 0;
            int numIncInden = 0;
            int numJvdMisng = 0;
            int numWtsMisng = 0;
            int numRetMisng = 0;
            int numParMisng = 0;
            int numMgcNumbr = 0;
            int numTypWrong = 0;
            int numCstWrong = 0;
            int numMtdWrong = 0;
            int numPrmWrong = 0;
            
            boolean hasAuthorTag = true;
            
            while ( reader.hasNextLine() ) {
                String line = reader.nextLine();
                
                // If the audit is complete.
                if ( line.contains(AUDIT_COMPLETE) ) {
                    break;
                }
                
                if (line.contains(INDENT_LEVEL) || 
                    line.contains(INDENT_LEVEL_TWO) || 
                    line.contains(DOING_STYLE) || 
                    line.contains(STARTING_AUDIT) ||
                    line.equals("")) {
                    
                    continue;
                    
                }
                
                //Removing a few things:
                
                // /afs/unity.ncsu.edu/users/*/
                line = line.substring(AFS_START_SUBSTRING_LENGTH);
                
                // unityid/folders/.../StudentLastName_
                line = line.substring(line.indexOf("_") + 1);
                
                // StudentFirstName/
                line = line.substring(line.indexOf("/") + 1);
                //System.out.println(line);
                
                //Final output: Program.java:##: Style Error
                
                javaFileName = line.substring(0, line.indexOf("."));
                
                // Check if a tab character was detected.
                if (line.contains("tab")) {
                    numTabLines++;
                }
                
                if ( line.contains("incorrect indentation") ) {
                    numIncInden++;
                }
                
                if ( line.contains("@author") ) {
                    hasAuthorTag = false;
                }
                
                if ( line.contains("Missing a Javadoc") ) {
                    numJvdMisng++;
                }
                
                if ( line.contains("WhitespaceAround:") ) {
                    numWtsMisng++;
                }
                
                if ( line.contains("@return") ) {
                    numRetMisng++;
                }
                
                if ( line.contains("@param") ) {
                    numParMisng++;
                }
                
                // Magic, or more magic?
                if ( line.contains("magic") ) {
                    numMgcNumbr++;
                }
                
                if ( line.contains("match pattern") ) {
                    if ( line.contains("Type name") ) {
                        numTypWrong++;
                    }
                    if ( line.contains("Constant name") ) {
                        numCstWrong++;
                    }
                    if ( line.contains("Method name") ) {
                        numMtdWrong++;
                    }
                    if ( line.contains("Parameter name") ) {
                        numPrmWrong++;
                    }
                    
                }
                
            }
            
            String initOutput = "Generated Report for " + javaFileName;
            writer.println(initOutput);
            
            if ( !hasAuthorTag ) {
                writer.println("File lacks an @author Tag.");
            }
            
            String outputLine = "Lines with tab characters detected : ";
            outputLine += numTabLines;
            writer.println(outputLine);
            
            outputLine = "Lines with incorrect indentation   : ";
            outputLine += numIncInden;
            writer.println(outputLine);
            
            if ( numTabLines != 0 && numIncInden != 0 ) {
                writer.println("Warning: Incorrect indentation could be due to tab characters.");
            }
            
            outputLine = "Lines with missing Javadoc Comments: ";
            outputLine += numJvdMisng;
            writer.println(outputLine);
            
            outputLine = "Whitespace errors (operators/loops): ";
            outputLine += numWtsMisng;
            writer.println(outputLine);
            
            outputLine = "Missing/Incorrect @return tags     : ";
            outputLine += numRetMisng;
            writer.println(outputLine);
            
            outputLine = "Missing/Incorrect @param tags      : ";
            outputLine += numParMisng;
            writer.println(outputLine);
            
            outputLine = "Detected magic numbers             : ";
            outputLine += numMgcNumbr;
            writer.println(outputLine);
            
            outputLine = "Number of types incorrectly named  : ";
            outputLine += numTypWrong;
            writer.println(outputLine);
            
            outputLine = "       constants incorrectly named : ";
            outputLine += numCstWrong;
            writer.println(outputLine);
            
            outputLine = "       methods incorrectly named   : ";
            outputLine += numMtdWrong;
            writer.println(outputLine);
            
            outputLine = "       parameters incorrectly named: ";
            outputLine += numPrmWrong;
            writer.println(outputLine);
            
            writer.println();
            writer.flush();
        
        }
    
    }

}
