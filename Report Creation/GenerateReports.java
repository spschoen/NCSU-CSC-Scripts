import java.util.*;
import java.io.*;
import java.nio.file.*;

/**
 * GenerateReports, will read through files created from saving stylechcker and create a user
 * readable version.  Does not print the lines of the error - will refactor code to do that.
 * @author Samuel Schoeneberger
 */
public class GenerateReports {

    /** number of text files to be read, generated by CompileAndExecuteScript.sh */
    public static final int READ_TEXT_FILES = 6;
    
    /** String printed out that is always at the end of usable data from file. */
    public static final CharSequence AUDIT_COMPLETE = "Audit done.";
    
    /** Tells us indent level, to skip over more importantly. */
    public static final CharSequence INDENT_LEVEL = "indent level";
    
    /** Same as above; sequence to skip. */
    public static final CharSequence INDENT_LEVEL_TWO = "(If this isn't";
    
    /** Checking for another line to skip. */
    public static final CharSequence DOING_STYLE = "** Doing style";
    
    /** Last to skip - from this point forwar, we care about input. */
    public static final CharSequence STARTING_AUDIT = "Starting audit...";
    
    public static final int AFS_START_SUBSTRING_LENGTH = 28;
    
    /**
     * Main method.  Program execution and all that.
     * Checks if we have the right number of arguments (1), then checks through the
     * first argument for a folder of folder of output files to generate reports.
     * @param args command line arguments
     */
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage: java GenerateReports directory_name");
            System.exit(1);
        }
        
        File folder = new File(args[0]);
        if ( !folder.isDirectory() ) {
            System.out.println("Error: supplied directory not a directory.");
            System.exit(1);
        }
        
        //Folders inside the directory
        File[] folders = folder.listFiles();
        
        //Files in each directory
        //[Number of folders][Number of text files to be read.]
        File[][] files = new File[folders.length][READ_TEXT_FILES];
        
        //Get files from each directory - the output.*.txt files specifically
        for ( int i = 0; i < folders.length; i++ ) {
            files[i] = folders[i].listFiles(new FilenameFilter(){
                @Override
	            public boolean accept(File directory, String fileName) {
                    return fileName.endsWith(".txt");
	            }
	        } );
        }
        
        PrintWriter writer = null;
        Scanner reader = null;
        
        for ( int i = 0; i < folders.length; i++ ) {
            
            // Setting up style file to be read.
            String styleFile = folders[i] + "/output_style.txt";
            File style = new File(styleFile);
            
            // Setting up report file to be written to.
            String reportFile = folders[i] + "/Report.txt";
            File report = new File(reportFile);
            
            // Making sure that report doesn't already exist.
            if ( report.exists() ) {
                report.delete();
            }
            
            // Making sure we have a style file to check
            if ( !style.exists() ) {
                System.out.println("No output for style in folder: " + folders[i]);
                continue; //Skip iteration, we couldn't find that style file.
            }
            
            // Making sure we can create that report file.
            try {
                report.createNewFile();
            } catch ( Exception e ) {
                System.out.println(e.getMessage());
                System.exit(1);
            }
            
            // Setting up our reader/writer combo.
            try {
                writer = new PrintWriter(report, "UTF-8");
                reader = new Scanner(style);
            } catch ( Exception e ) {
                System.out.println(e.getMessage());
                System.exit(1);
            }
            
			String javaFileName = "";
			int numTabLines = 0;
			int numIncInden = 0;
			int numJvdMisng = 0;
			int numWtsMisng = 0;
			int numRetMisng = 0;
			int numParMisng = 0;
			int numMgcNumbr = 0;
			int numTypWrong = 0;
			int numCstWrong = 0;
			int numMtdWrong = 0;
			int numPrmWrong = 0;
			int numLongLine = 0;
			int uknownError = 0;
            
            boolean hasAuthorTag = true;
            
            while ( reader.hasNextLine() ) {
				String line = reader.nextLine();
				
				// If the audit is complete.
				if ( line.contains(AUDIT_COMPLETE) ) {
					break;
				}
				
				if (line.contains(INDENT_LEVEL) || 
					line.contains(INDENT_LEVEL_TWO) || 
					line.contains(DOING_STYLE) || 
					line.contains(STARTING_AUDIT) ||
					line.equals("")) {
					
					continue;
					
				}
				
				//Removing a few things:
				
				// /afs/unity.ncsu.edu/users/* /
				line = line.substring(AFS_START_SUBSTRING_LENGTH);
				
				// unityid/folders/.../StudentLastName_
				line = line.substring(line.indexOf("_") + 1);
				
				// StudentFirstName/
				line = line.substring(line.indexOf("/") + 1);
				//System.out.println(line);
				
				//Final output: Program.java:##: Style Error
				
				javaFileName = line.substring(0, line.indexOf("."));
				
				// Check if a tab character was detected.
				if (line.contains("tab")) {
					numTabLines++;
				} else if ( line.contains("incorrect indentation") ) {
					numIncInden++;
				} else if ( line.contains("@author") ) {
					hasAuthorTag = false;
				} else if ( line.contains("Missing a Javadoc") ) {
					numJvdMisng++;
				} else if ( line.contains("WhitespaceAround:") ) {
					numWtsMisng++;
				} else if ( line.contains("@return") ) {
					numRetMisng++;
				} else if ( line.contains("@param") ) {
					numParMisng++;
				} else if ( line.contains("magic") ) {
					numMgcNumbr++;
				} else if ( line.contains("match pattern") ) {
					if ( line.contains("Type name") ) {
						numTypWrong++;
					}
					if ( line.contains("Constant name") ) {
						numCstWrong++;
					}
					if ( line.contains("Method name") ) {
						numMtdWrong++;
					}
					if ( line.contains("Parameter name") ) {
						numPrmWrong++;
					}
					
				} else if ( line.contains("longer than") ) {
					numLongLine++;
				} else {
					uknownError++;
				}
                
			}
			
			String initOutput = "Style Report for " + javaFileName + "\n";
			writer.write(initOutput);
			
			if ( !hasAuthorTag ) {
				writer.write("File lacks an @author Tag.\n");
			}
			
			String outputLine = "Lines with tab characters detected : ";
			outputLine += numTabLines + "\n";
			writer.write(outputLine);
			
			outputLine = "Lines with incorrect indentation   : ";
			outputLine += numIncInden + "\n";
			writer.write(outputLine);
			
			if ( numTabLines != 0 && numIncInden != 0 ) {
				writer.write("Warning: Incorrect indentation could be due to tab characters.\n");
			}
			
			outputLine = "Lines with missing Javadoc Comments: ";
			outputLine += numJvdMisng + "\n";
			writer.write(outputLine);
			
			outputLine = "Whitespace errors (operators/loops): ";
			outputLine += numWtsMisng + "\n";
			writer.write(outputLine);
			
			outputLine = "Missing/Incorrect @return tags     : ";
			outputLine += numRetMisng + "\n";
			writer.write(outputLine);
			
			outputLine = "Missing/Incorrect @param tags      : ";
			outputLine += numParMisng + "\n";
			writer.write(outputLine);
			
			outputLine = "Detected magic numbers             : ";
			outputLine += numMgcNumbr + "\n";
			writer.write(outputLine);
			
			outputLine = "Number of lines longer than allowed: ";
			outputLine += numLongLine + "\n";
			writer.write(outputLine);
			
			outputLine = "Number of types incorrectly named  : ";
			outputLine += numTypWrong + "\n";
			writer.write(outputLine);
			
			outputLine = "       constants incorrectly named : ";
			outputLine += numCstWrong + "\n";
			writer.write(outputLine);
			
			outputLine = "       methods incorrectly named   : ";
			outputLine += numMtdWrong + "\n";
			writer.write(outputLine);
			
			outputLine = "       parameters incorrectly named: ";
			outputLine += numPrmWrong + "\n";
			writer.write(outputLine);
			
			outputLine = "Number of unknown errors detected  : ";
			outputLine += uknownError + "\n";
			writer.write(outputLine);
			
			writer.println();
			writer.flush();
        
        }
    
    }

}
